Little-endian - Data is written from the right to the left. 
mov eax, \[0x410230] - Move data at memory location 0x410230 into eax.
 
 ## CPU Instructions
Data manipulation
- ADD, SUB, SHR, AND, OR, XOR
	- SUB will subtract and change the register
	- CMP will subtract to see if it enters negative space. register is not changed
	- AND tests for Zero or non-Zero.  AND 0 with 0 you get 0, AND with anything else, you get non-Zero. 
	- TEST will do the same as AND but is implied and does not change the value in the operand.
Data transfer
- PUSH, POP, MOV, XCHG, LEA
Branching and conditionals
- JMP, CALL, RET, CMP

- **mov** - Move data in and out of registers and the stack.
- **jmp**, jnz, jz, jne, je - Jump, a movement instruction. Logical branching. Looks for a condition to be met and make a jump to another part of the program depending on the condition outcome.
- **sub** - Subtract numbers from other numbers. Subtract locations in memory from the stack.
- **push** - Push data onto the top of the Stack. As data is pushed to the stack they are assigned lower addresses.
- **pop** - Pops data off the bottom of the Stack.
- **call** -Main ( ) Calls a function. 
- **ret** - Returns the outcome to of a function that was called to Main ( ).
- test is an implied and. Are contents zero?
- cmp is an implied sub. Compares two registers.
- **LEA** - Load Effective Address

**JUMP**
Jcc
- A=above, B=below, E=equal, N=not, G=greater than, L=less than, Z=zero,
JZ = Jump if zero
JNZ = Jump if not zero
JA = Jump if above
JNGE = Jump if not greater than or equal

## Functions
- Takes an Input (Values passed in), Body (Code to perform the task), and a Return (Value passed back)
- Involves two control transfers.
	- Calling a function
		- Pass parameters to stack
		- Stave return pointer
		- Transfer control to function.
	- Returning from a function
		- Set up Return value (Typically EAX)
		- Clean up the stack and restore registers
- Prologue occurs at the start of a function.
	- It allocates space for variables.
	- It saves registers that will be reused in the function body.
- Epilogue occurs at the end of a function
	- It cleans up the stack (e.g., POP allocated variables).
	- It restores registers


## Memory Registers
**32bit**
- **EAX** - Accumulator Register - Used for addition and multiplication.  In many cases EAX is used to store results of of a function to be returned.
- **ECX** - Used as a counter. For example, count loop iterations.
- **edx** - Data Register
- **ebx** - Base Register
- **ESP** - Extended Stack Pointer. Points to the last item on a stack. Top of the stack.
- **EBP** - Extended Base Pointer. Used to reference arguments and local variables. Register that can store the location to return to after jumping to another function. 
	- Serves as an unchanging reference.
	- Pushed to the stacked then referenced to pull local variables and parameters
	- EBP (-) minus value = local variable (registers may also be used)
	- EBP(+) plus value = parameter
- **ESI/EDI** - Used by memory transfer instructions.
-  **EIP** - Extended Instruction Pointer - Current position of the running code in Assembly. Next instruction to execute.
- **EFLAGS** -- Bits represent the outcome of computations, and they control CPU operation. Example is the Zero flag.
**Segment Registers** - Typically not useful as analysist.
- CS: Code segment
- DS: Data segment
- SS: Stack segment

**32 bit registers at 16 and 8 bit.**
- EAX - 32 bit
	- AX - 16 bit Low bits of register
	- AH - 8 bit High bits of AX
	- AL - 8 bit Low bits of AX
	

- EAX = 0x68776453
	- AX = 0x6453
	- AH = 0x64
	- AL = 0x53

**Word Length**
- byte - 8 bit
- word - 16 bit
- dword - 32 bit
- qword - 64 bit

Memory can be accessed directly. This is shown by the memory address being shown in brackets.
Example mov eax, \[0x410425]
IDA omits the brackets and shows dword_410425 instead of \[0x410425]
mov eax, dword_410425

Indirectly address memory by calling a register plus or minus.
MOV EAX, \[EBP + 0x10]



**64bit**
- rip
## The Stack
Grows downwards.  Top of the stack is the highest possible address in the stack for the program. LIFO Last in First out.


